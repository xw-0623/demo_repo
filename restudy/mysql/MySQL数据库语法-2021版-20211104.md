# MySQL数据库语法

[toc]

整体教学思路

- 时间安排：4个工作日

- 上课方式：讲解+演示，每节课录屏，按知识点命名录屏文件（格式示例：01 数据库入门）每天发给学生，所有演示的语句写到一个SQL脚本文件中，每天把这个文件分享给学生参考，每天的笔记整理在幕布上，分享给学生。每天给学生发的包括：录屏、上课演示的SQL脚本、幕布笔记。

- 演示数据库：前6章的演示，基于test_db（学生表、课程表、成绩表、教师表等，这也是面试喜欢用的一个数据库），从第8章开始，基于crashcourse数据库演示。

## 1. 数据库基础

### 1.1 什么是数据库（DB）

***思路：以科瑞举例，讲清楚数据库在软件系统中的作用。***

数据库：Database，简称DB，是按照数据结构来组织、存储和管理数据的仓库。

我们软件系统的数据，就是存放在数据库中的，比如淘宝的用户信息、商品信息、订单信息等，都是存放在数据库中，我们在浏览淘宝网站的时候，后台程序从数据库中把数据查出来展示在页面上，当我们下单的时候，会生成一条订单信息，保存在数据库中。

科瑞系统添加学员的过程：

<img src="https://gitee.com/charlesshenchuan/markdown-image-bed/raw/master/Typora/img/image-20211025131352167.png" alt="image-20211025131352167" style="zoom:67%;" />



### 1.2 什么是数据库管理系统（DBMS）

***思路：讲清楚数据库管理软件的作用，以及数据库和数据库管理软件的区别。***
用于管理数据库的软件称为数据库管理软件（DBMS：Database Management System）。

对数据库的操作与管理是通过该数据库管理软件来完成的。

行业中主流的数据库管理软件有：MySQL、MariaDB、Oracle、DB2、SQL Server、Redis、MongoDB等，本课程讲解MySQL的使用。

<img src="https://gitee.com/charlesshenchuan/markdown-image-bed/raw/master/Typora/img/image-20210920225950576.png" alt="image-20210920225950576" style="zoom:67%;" />



### 1.3 数据库管理系统的类型

***思路：讲清楚关系型数据库和非关系数据库的区别、各关系型数据库的关系特别是MySQL与MariaDB的关系***

数据库管理系统（DBMS）可以分为关系型数据库管理系统（RDBMS）和非关系型数据库管理系统。

1. 关系型数据库

  常用的关系型数据库：MySQL、MariaDB、Oracle、DB2、SQL Server、SQLite、Access等

  特点：
  - 数据以二维表格的形式存储，一类数据一般放在一张表中（类似Excel的表格），比如学生的信息放在学生表中；
  - 一张表由许多行和列组成，每列为各种记录名称，也叫字段，每行为记录名称所对应的数据，也叫一条记录；
  - 一个数据库由很多张表组成；
  - 在数据库管理系统上可以创建很多个数据库。

  常用的关系型数据库介绍：

  - MySQL：由瑞典的MySQL AB公司开发，后来被甲骨文（Oracle）公司收购，是最流行的关系型数据库管理系统之一，在Web应用当面MySQL是最好的RDBMS之一。MySQL 软件采用了双授权政策，分为社区版和商业版。
  - Oracle：商业的软件，甲骨文公司开发，功能强、性能好，在中大型系统中广泛使用，多用于通信、银行等领域。
  - MariaDB：MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。开发这个分支的原因之一是：甲骨文公司收购了MySQL后，有将MySQL闭源的潜在风险，因此社区采用分支的方式来避开这个风险。CentOS从7版本开始自带的数据库就是MariaDB。

  **所有关系型数据库的语法都是基于SQL（结构化查询语言）语言实现，MySQL用的是标准的SQL语言，我们上课学的MySQL的语句，大部分都适用于其它关系型数据库。**

2. 非关系型数据库

  常用的非关系型数据库管理系统：Redis、MongoDB、Memcached、Neo4j等。与关系型数据库中数据是基于表存储的不同，非关系型数据库中的数据有的是基于键值对存储的（Redis、Memcached），有的是基于文档存储的（MongoDB），有的是基于图片存储的（Neo4j）。

  特点：

  - 数据的读写相对更快，性能更好；可以利用这个特点，把一些热门的数据缓存到非关系型数据库中，提高查询的性能。
  - 每种非关系数据库的语法不一样，学习成本较高。

  

  有的项目中，可能是MySQL+Redis组合使用，也有可能只用关系型数据库。我们上课主要讲解关系型数据库MySQL。

  

### 1.4 工作中哪些时候需要用到数据库

1. 搭建环境的时候需要安装数据库，并在数据库中构造初始化数据，比如系统的管理员账号就是预设在数据库中的；
2. 在测试过程中，有时需要查询数据库来验证用例通过与否（这个过程叫断言，也就是对比预期结果跟实际结果），有的时候查数据库会更简单，有的系统没有页面，只能查数据库校验用例通过与否；
3. 有些时候验证功能，需要修改数据库中的数据来构造对应的场景；
4. 在测试中，有的数据只能通过查数据库获取到，在页面上查不到；
5. 有的时候，需要统计一些数据，直接查询数据库更方便。



### 1.5 MySQL数据库的安装与连接

#### 1.5.1 安装MySQL服务器端

MySQL可以通过以下方式安装，本课程中通过源码的方式安装。

1. 通过源码编译安装；

   步骤：先安装工具，再下载源码，配置源码，编码，再安装，安装后再完成一些配置工作。

   参考：软件测试环境的搭建系列：[2] MySQL数据库的安装 - 蓉华教育的文章 - 知乎 https://zhuanlan.zhihu.com/p/38087381

2. 通过yum install命令安装；

3. rpm包安装，先下载rpm包，再执行rpm -ivh xxx.rpm命令来安装；

4. 通过docker容器安装。

#### 1.5.2 安装MySQL客户端并连接服务器端

MySQL客户端：SQLyog、Navicat、Workbench等，本课程中使用SQLyog客户端。

通过SQLyog连接MySQL数据库：

![image-20210923224357798](https://gitee.com/charlesshenchuan/markdown-image-bed/raw/master/Typora/img/image-20210923224357798.png)

注意：通过源码安装的MySQL的root用户默认没有远程连接权限，需要按如下步骤配置远程访问权限。

软件测试环境的搭建系列：[10] 设置MySQL的root账户允许远程连接 - 蓉华教育的文章 - 知乎 https://zhuanlan.zhihu.com/p/91663043



## 2. MySQL数据库的基本概念

### 2.1 表（Table）

关系数据库中的数据是保存在表里面的，存储在表中的数据是一种特定类型的数据。在数据库中，表有一个唯一的名字来标识该表，称为表名。

表定义了数据在表中如何存储，如：可以存在什么样的数据、数据如何分解、各部分信息如何命名等；比如：将京东的客户信息保存在一个顾客表中可以取名为customers。

一个数据库可以有很多张表。



### 2.2 列（Column/Field）

表由列组成，列中存储着表中某部分的信息；所有表都是由一个或多个列组成的，一列也叫一个字段。

比如：在学生表中，一个学生信息如下：学号、姓名、性别、班级、年龄、手机号等，相同的属性的值都存放在一列，比如学号存放在一列，姓名存放在一列![image-20210920231205211](https://gitee.com/charlesshenchuan/markdown-image-bed/raw/master/Typora/img/image-20210920231205211.png)

一张表可以有很多个列（字段）。



### 2.3 行（Row）

表中的数据是按行存储的，一行就是一条记录。

如果将表想象成网格，网格中垂直的行为表列，水平的行为表行。

![image-20210928173923076](https://gitee.com/charlesshenchuan/markdown-image-bed/raw/master/Typora/img/image-20210928173923076.png)

一张表中可以有多行（多条数据）。



###2.4 MySQL软件、数据库、表、列、行的关系

在MySQL软件系统可以创建很多个数据库，每个数据库可以有多个表，每个表可以有多个列（字段），每个表可以有多行数据。

<img src="https://gitee.com/charlesshenchuan/markdown-image-bed/raw/master/Typora/img/z2ok4sifawy.png" alt="img" style="zoom:67%;" />



## 3. 数据库的创建、连接、删除等操作

### 3.1 创建数据库
- 语法：

  - create database 数据库名称;
  - create database if not exists 数据库名称;    #如果数据库不存在就创建，存在就不创建，也不会报错

- 举例：

  ``````sql
  #创建一个不存在的数据库ronghua_db，会创建成功
  mysql> create database ronghua_db;
  Query OK, 1 row affected (0.00 sec)
  
  #创建一个已存在的数据库ronghua_db，会报错提示数据库已存在
  mysql> create database ronghua_db;
  ERROR 1007 (HY000): Can't create database 'ronghua_db'; database exists
  
  #加上IF NOT EXISTS判断，如果存在就不创建，这样就不会报错
  mysql> create database if not exists ronghua_db;
  Query OK, 1 row affected, 1 warning (0.00 sec)
  ``````



### 3.2 查询数据库的建库语句

- 语法：show create database 数据库名称;

- 作用：可以反向地把创建数据库的语句查出来。

- 举例：

  ```sql
  mysql> show create database crashcourse;
  +-------------+----------------------------------------------------------------------+
  | Database    | Create Database                                                      |
  +-------------+----------------------------------------------------------------------+
  | crashcourse | CREATE DATABASE `crashcourse` /*!40100 DEFAULT CHARACTER SET utf8 */ |
  +-------------+----------------------------------------------------------------------+
  1 row in set (0.00 sec)
  ```

  

### 3.3 查询有哪些数据库

- 语法：show databases;

- 举例：

  ```sql
  #如下表示总共有12个数据库
  mysql> show databases;
  +--------------------+
  | Database           |
  +--------------------+
  | information_schema |
  | crashcourse        |
  | jforum             |
  | korei              |
  | mysql              |
  | performance_schema |
  | testdb             |
  +--------------------+
  12 rows in set (0.02 sec)
  ```
  
  

### 3.4 选择数据库

- 语法：use 数据库名称; 

- 举例：

  ```sql
  #连接数据库test_db
  mysql> use test_db;
  Reading table information for completion of table and column names
  You can turn off this feature to get a quicker startup with -A
  
  Database changed
  ```
  
  选择数据库后，后续的操作就是在这个数据库里进行的。
  
  

### 3.5 删除数据库

- 语法：

  - drop database 数据库名称;
  - drop database if exists 数据库名称;     #如果数据库存在就删除，如果不存在也不报错

- 举例：

  ```sql
  #删除数据库test_db
  mysql> drop database test_db;
  Query OK, 0 rows affected (0.06 sec)
  ```
  
  删除数据库，会连同删除数据库里的所有数据。
  
  当删除一个不存在的数据库时，系统会报错，这时建议在删除语句中使用if exists来判断是否存在，如果存在就删除，如果不存在就不删。
  
  举例：
  
  ```sql
  #删除一个不存在的数据库，加上IF EXISTS就不会报错
  mysql> drop database if exists test_db;
  Query OK, 0 rows affected, 1 warning (0.00 sec)
  ```
  
  

### 3.6 查看MySQL的系统变量

- MySQL中有很多系统变量，在工作中可能需要涉及到修改或查询某个变量。

- 语法：

  - 查询所有的系统变量：show variables;
  - 查询指定的某个系统变量，可以用一下两种方式：
    - show variables like "变量名"；       #查询某个变量的值
    - show variables like "%关键字%";   #根据关键字模糊查询变量的值
    - select @@变量名;                                 #查询某个变量的值

- 举例：

  ```sql
  #查询所有系统变量
  mysql> show variables;
  +--------------------------------+-------+
  | Variable_name                  | Value |
  +--------------------------------+-------+
  | auto_increment_increment       | 1     |
  | auto_increment_offset          | 1     |
  | autocommit                     | ON    |
  | automatic_sp_privileges        | ON    |
  
  #查询变量autocommit的值
  mysql> show variables like "autocommit";
  +---------------+-------+
  | Variable_name | Value |
  +---------------+-------+
  | autocommit    | ON    |
  +---------------+-------+
  1 row in set (0.00 sec)
  
  #查询指定的某个系统变量
  mysql> show variables like "%commit%";
  +--------------------------------+-------+
  | Variable_name                  | Value |
  +--------------------------------+-------+
  | autocommit                     | ON    |
  | binlog_order_commits           | ON    |
  | innodb_api_bk_commit_interval  | 5     |
  | innodb_commit_concurrency      | 0     |
  | innodb_flush_log_at_trx_commit | 1     |
  +--------------------------------+-------+
  5 rows in set (0.00 sec)
  
  #查询指定的某个系统变量，如下autocommit变量为1表示数据库会对增删改操作执行自动提交
  mysql> select @@autocommit;
  +--------------+
  | @@autocommit |
  +--------------+
  |            1 |
  +--------------+
  1 row in set (0.00 sec)
  ```
  
  

## 4. 数据类型

### 4.1 数值型

- 整型
  - tinyint：1字节，非常小的整数，带符号：-128\~127，不带符合：0~255；
  - <font color='red'> int：4字节，标准整型，带符号：-2147483648\~2147483647，不带符号：0~4294967295；</font>
  - 其他类型：smallint（2字节）、mediumint（3字节）、bigint（8字节）；
- 浮点型：表示小数，浮点数只能表示近似值，不能表示精确值
  - float：4字节，单精度浮点数；
  - double：8字节，双精度浮点数；
- <font color='red'> decimal(m,d)：m表示整数加小数的总位数，d表示小数位数，比如decimal(4,2)；</font>
- 区别：float与double存储的是近似值，decimal存储的是精确值。**在数据库中涉及到钱的金额，一定要用decimal类型。**

### 4.2 字符串型

- 字符串：一串字符，字符可以由中文、英文、数字组成
  - <font color='red'> char(m)：最多可以容纳m个字符；比如char(5)最多可以存5个字符串（abcde）</font>
  - <font color='red'> varchar(m)：最多可以容纳m个字符，如果存储的字符数n少于m时，实际占用的存储空间是L+1个字节，其中L是n个字符占用的字节数，多出的1个字节是用来记录实际存储长度的；</font>
  - 其他类型：blob（longblob），text（longtext）
  - char和varchar是最常用的两种字符串类型，他们的区别是：

    - char是固定长度的，每个值占用相同的字符数，不够的位数MySQL会在它的右边用空格字符补足

    - varchar是一种可变长度的类型，每个值占用其刚好的字符数再加上一个用来记录其长度的字节即L+1个字节
  - 在使用时，char和varchar怎么选择：

    - 如果数据都有相同的长度（比如手机号码），选用varchar会多占用空间，因为有一位用来存储其长度。如果数据长度不一，选用varchar能节省存储空间；
    - 而char不论字符长短都需要占用相同的空间，即使是空值也不例外。

### 4.3 日期时间型

- <font color='red'> year：表示年，比如2000</font>
- <font color='red'>date：日期型，表示一个日期格式，如2020-01-01</font>
- <font color='red'> time：时间型，表示一个时间格式，如22:10:15</font>
- <font color='red'> datetime：日期时间型，表示一个日期+时间的组合格式，如2020-01-01 22:10:15</font>
- timestamp：时间戳型，如果某列的数据类型为timestamp且该列为not null，当插入数据时不指定该列的值，那么这个列就会自动取值为当前的日期和时间；在创建和修改数据行时，如果没有明确对timestamp数据列进行赋值，则它就会自动取值为当前的日期和时间。如果表中有多个timestamp列，只有第一个会自动取值。

### 4.4 枚举类型

- enum：枚举类型，当一个字段的值只能在某个范围内取值，比如性别只能取男或女，可以用enum("男","女")来表示，这个字段在插入数据时只能取男或者女或者不传值。每个枚举值都有一个索引，第一个值的索引为1。枚举类型的好处是MySQL在存储此类数据时，直接转化成数字存储而不是字符串，可以节省空间，并且在表的.frm文件中存储“数字-字符串”之间的对应关系。

  

## 5. 表的创建、修改、删除等操作

### 5.1 表的主键（Primary Key）

主键：唯一标识表中每行的一列（或几列的组合）称为主键，主键也称主关键字。

表中任何列都可以作为主键，但需要满足以下条件：

1. 任意两行都不具有相同的主键值，即主键值不重复；

2. 每个行都必须具有一个主键值，即主键值不能为空（NULL）。


主键用来表示一个特定的行，如果没有主键，更新或删除表中特定的行会很困难，因为没有安全的方法保证只涉及相关的行。

![image-20210920231615155](https://gitee.com/charlesshenchuan/markdown-image-bed/raw/master/Typora/img/image-20210920231615155.png)

**一张表只能有一个主键，但这个主键可以是一列，也可以是多列的组合；如果是多列的组合，那么多列的组合必须满足上面的两个条件。**



### 5.2 表的外键（Foreign Key）

外键：外键用于关联两张表，外键为表中的一列，它同时又是另一个表的主键，定义了两个表之间的关系，外键又称作外关键字。

主表与从表：以另一个表的外键作为主键的表被称为主表，具有此外键的表被称为主表的从表。

一张表可以有多个外键，每个外键分别关联不同主表的主键。

![image-20210920231706817](https://gitee.com/charlesshenchuan/markdown-image-bed/raw/master/Typora/img/image-20210920231706817.png)

外键的作用：

1. 外键用于关联两张表；
2. 保持数据一致性，完整性，主要目的是控制存储在外键表中的数据，存储在从表中的外键值只能引用主表中的主键值或使用空值。

最直观的作用是防止非法数据录入，就是说录入外键数据时必须在它所属的主表中存在的相应数据，如果录入其他数据会报错。

外键的功能由两种方法实现：

- 1）阻止执行
  1. 从表插入新行，其外键值不是主表的主键值便阻止插入；
  2. 从表修改外键值，新值不是主表的主键值便阻止修改；
  3. 主表删除行，其主键值在从表里存在便阻止删除(要想删除，必须先删除从表的相关行)；
  4. 主表修改主键值，旧值在从表里存在便阻止修改(要想修改，必须先删除从表的相关行)。

- 2）级联执行
  1. 主表删除行，连带从表的相关行一起删除；
  2. 主表修改主键值，连带从表相关行的外键值一起修改。

两种方法提供给用户选择。无论选取哪种方法，从表里都不会有多余行。从另一个角度理解，用拒绝同一事物在从表中的标志与主表不一致来实现与主表中的标志一致。

两种实现方法，通过下在创建外键时指定更新和删除的CASCADE、RESTRICT选项来实现，CASCADE为级联执行、RESTRICT为阻止执行，默认为RESTRICT。

表的主键和外键举例：![image-20210821145829811](https://gitee.com/charlesshenchuan/markdown-image-bed/raw/master/Typora/img/image-20210821145829811.png)

### 5.3 创建表

- 语法：create table 表名 (字段1 数据类型 属性,字段2 数据类型 属性, ..., primary key(主键字段)) engine=引擎;

- 注：我们的数据库安装后默认使用的是InnoDB引擎，可以通过show engines语句来查询数据库支持哪些引擎。

- 举例：

  ```sql
  #创建学生表，包含学号、姓名、性别、出生日期四个字段，指定引擎为INNODB
  mysql> create table students (id_ int not null,name_ varchar(20) not null,sex_ enum("男","女"),birthday_ date, primary key(id_)) engine=innodb;
  Query OK, 0 rows affected (0.01 sec)
  
  #创建一个老师表，包括老师编号、姓名、性别、家庭住址，默认家庭住址是蜀都中心
  create table teachers (id int not null,tname varchar(20) not null,sex enum("男",
  "女"),address varchar(20) default "蜀都中心");
  #插入一条数据，不插入address的值，会使用默认值“蜀都中心”
  insert into teachers (id,tname,sex) values (1,"小明","男");
  ```

- 说明：通过primary key(主键字段)来指定主键。



### 5.4 查看表的结构

- 语法：desc 表名;

- 举例：

  ```sql
  #查看uc_demension表的结构
  mysql> desc uc_demension;
  +----------------+--------------+------+-----+---------+-------+
  | Field          | Type         | Null | Key | Default | Extra |
  +----------------+--------------+------+-----+---------+-------+
  | ID_            | varchar(64)  | NO   | PRI | NULL    |       |
  | DEM_NAME_      | varchar(64)  | YES  |     | NULL    |       |
  | CODE_          | varchar(64)  | YES  | MUL | NULL    |       |
  | IS_DEFAULT_    | int(11)      | YES  |     | NULL    |       |
  | DEM_DESC_      | varchar(255) | YES  |     | NULL    |       |
  | ORGAN_ID_      | varchar(64)  | YES  |     | NULL    |       |
  | IS_DELE_       | char(1)      | YES  |     | 0       |       |
  | VERSION_       | int(11)      | YES  |     | NULL    |       |
  | UPDATE_TIME_   | datetime     | YES  |     | NULL    |       |
  | CREATE_BY_     | varchar(64)  | YES  |     | NULL    |       |
  | CREATE_TIME_   | datetime     | YES  |     | NULL    |       |
  | CREATE_ORG_ID_ | varchar(64)  | YES  |     | NULL    |       |
  | UPDATE_BY_     | varchar(64)  | YES  |     | NULL    |       |
  | TENANT_ID_     | varchar(64)  | YES  |     | NULL    |       |
  +----------------+--------------+------+-----+---------+-------+
  14 rows in set (0.00 sec)
  ```



###5.5 修改表添加外键

- 语法：alter table 从表名称 add constraint 外键名称 foreign key(外键) references 主表名称(主键);

- 举例：

  ```sql
  #修改course表，指定teacher_id作为外键，关联教师表的teacher_id
  alter table course add constraint fk_course_teacher foreign key(teacher_id) references teacher(teacher_id);
  ```

  

### 5.6 在表中增加一个字段

- 语法：alter table 表名 add 字段名 数据类型 属性;

- 举例：

  ```sql
  #在students表中增加字段age_
  mysql> alter table students add age_ int;
  Query OK, 0 rows affected (0.02 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  ```



### 5.7 修改表的字段

- 语法：
  - alter table 表名 modify 列名 新数据类型 新属性;
  - alter table 表名  change 旧列名 新列名 新数据类型 新属性;

  其中，modify只能改变列的数据类型与属性，change可以改变列名及属性。

- 举例：

  ```sql
  #把字段name_的数据类型改成varchar(30)，非空
  mysql> alter table students modify name_ varchar(30) not null;
  Query OK, 0 rows affected (0.01 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  #把字段birthday_的名称改为birthdate_，数据类型为datetime，非空
  mysql> alter table students change birthday_ birthdate_  datetime not null;
  Query OK, 0 rows affected (0.09 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  #修改后查看表的结构，可以看到字段已经被修改成功
  mysql> desc students;
  +------------+-------------------+------+-----+---------+-------+
  | Field      | Type              | Null | Key | Default | Extra |
  +------------+-------------------+------+-----+---------+-------+
  | ID_        | int(11)           | NO   | PRI | NULL    |       |
  | NAME_      | varchar(30)       | NO   |     | NULL    |       |
  | SEX_       | enum('男','女')   | YES  |     | NULL    |       |
  | BIRTHDATE_ | datetime          | NO   |     | NULL    |       |
  +------------+-------------------+------+-----+---------+-------+
  4 rows in set (0.00 sec)
  ```



### 5.8 在表中删除一个字段

- 语法：alter table 表名 drop 字段名;

- 举例：

  ```sql
  #删除students表中的age_字段
  mysql> alter table students drop age_;
  Query OK, 0 rows affected (0.02 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  ```



### 5.9 重命名表

- 语法：alter table 当前表名 rename to 修改后的表名;

- 举例：

  ```sql
  mysql> alter table students rename to students_info;
  Query OK, 0 rows affected (0.01 sec)
  ```



### 5.10 删除一张表

- 语法：

  - drop table 表名;
  - drop table  if  exists 表名;    #如果表存在就删除，如果不存在也不报错

- 举例：

  ```sql
  #删除表students
  mysql> drop table students;	
  Query OK, 0 rows affected (0.00 sec)
  ```

### 5.11 查询数据库中有哪些表

- 语法：show tables;

- 举例：

  ```sql
  mysql> show tables;
  +----------------------+
  | Tables_in_ronghua_db |
  +----------------------+
  | course               |
  | xueshengs            |
  +----------------------+
  2 rows in set (0.00 sec)
  ```

  

## 6. 表数据的增删改操作

### 6.1 插入数据
- 语法：

  - insert into 表名 ( 字段1, 字段2,...字段n ) values ( 值1, 值2,...值n );
  - insert into 表名 values ( 值1, 值2,...值n );

- 举例：

  ```sql
  #场景一：插入一条数据，指定字段名称，插入所有字段的值，
  mysql> insert into students (id_,name_,sex_,birthday_) values (1,"张三","男","2001-1-1");
  Query OK, 1 row affected (0.00 sec)
  
  #场景二：插入一条数据，指定字段名称，只插入必填值
  mysql> insert into students (id_,name_) values (2,"李四");
  Query OK, 1 row affected (0.00 sec)
  
  #场景三：插入一条数据，不写字段名称，直接写数据，但这种情况下需要对所有字段插入值，并且值的顺序必须与表中的字段顺序保持一致
  mysql> insert into students values (3,"李四","男","2001-1-1");
  Query OK, 1 row affected (0.00 sec)
  
  #场景四：插入多条数据：每条数据用小括号括起来，小括号之间用逗号隔开
  mysql> insert into students values (4,"王五","男","2001-1-1"),(5,"赵六","男","2001-1-1"),(6,"刘七","男","2001-1-1");
  Query OK, 3 rows affected (0.00 sec)
  Records: 3  Duplicates: 0  Warnings: 0
  ```



### 6.2 删除数据

- 语法：delete from 表名 [where子句];

  在删除数据是一般要使用where子句来指定删除特定的行，否则会删除表的所有行。

- 举例：

  ```sql
  #删除张三的信息
  mysql> delete from students where name_="张三";
  Query OK, 1 row affected (0.00 sec)
  
  #快速清空学生表的数据
  truncate students;
  ```

- 快速清空表的数据：truncate table 表名 或者 truncate 表名;

- delete from与truncate的区别：如果要清空表的所有数据，可以使用truncate语句，而且速度比delete from语句快，truncate语句是先删除整张表，然后重新创建一个空表，而delete from是逐行删除表中的数据；另外truncate删除的数据不可恢复，而delete from删除的数据时可以恢复的。

- 面试问题：怎么快速清空一张表的数据？

  - truncate 表名;



### 6.3 修改数据

- 语法：

  - update 表名 set 字段1=值1 [where子句];
  - update 表名 set 字段1=值1, 字段2=值2 [where子句];

  在修改数据是一般要使用WHERE子句来指定修改特定的行，否则会修改表的所有行。

- 举例：

  ```sql
  #把张三的性别改成女
  mysql> update students set sex_="女" where name_="张三";
  Query OK, 1 row affected (0.01 sec)
  Rows matched: 1  Changed: 1  Warnings: 0
  ```



## 7. 上课演示的数据库的表结构讲解

![image-20210818150858043](https://gitee.com/charlesshenchuan/markdown-image-bed/raw/master/Typora/img/image-20210818150858043.png)

- customers：客户表，存放的是客户的信息，cust_id是customers表的主键

  - cust_id：客户id

  - cust_name：客户姓名

  - cust_address：客户地址

  - cust_city：客户城市

  - cust_state：客户所在的州

  - cust_zip：客户邮编

  - cust_country：客户国家

  - cust_contact：客户联系人

  - cust_email：客户邮箱地址

- orders：订单表，存放的是订单的信息，order_num是这个表的主键，cust_id是orders表的外键，关联customers表的cust_id

  - order_num：订单编号

  - order_date：订单日期时间

  - cust_id：客户id

- orderitems：订单详情表，存放的是每个订单里购买的产品的信息，order_num和order_item的组合是orderitems表的主键；order_num是外键，关联的是orders表的order_num；prod_id也是外键，关联的是products表的prod_id

  - order_num：订单编号

  - order_item：每个订单里的每种产品的编号

  - prod_id：产品id

  - quantity：数量

  - item_price：产品单价

- products：产品表，存放的是产品的信息，prod_id是主键，vend_id是外键，关联的是vendors表的vend_id

  - prod_id：产品id

  - vend_id：供应商id

  - prod_name：产品名称

  - prod_price：产品价格

  - prod_desc：产品描述

- vendors：供应商表，存放的是供应商的信息，vend_id是它的主键

  - vend_id：供应商id

  - vend_name：供应商名称

  - vend_address：供应商地址

  - vend_city：供应商城市

  - vend_state：供应商州

  - vend_zip：供应商邮编

  - vend_country：供应商国家

- productnotes：产品的注释表



## 8. 表的查询

### 8.1 查询表的一个或多个字段的值

- 语法：select 字段1,字段2,... from 表名;

- 举例：

  ```sql
  #查询客户ID和Name
  mysql> select cust_id,cust_name from customers;
  +---------+----------------+
  | cust_id | cust_name      |
  +---------+----------------+
  |    1003 | ACME           |
  |   10001 | Coyote Inc.    |
  |   10005 | E Fudd         |
  |    1004 | Furball Inc.   |
  |    1005 | Jet Set        |
  |    1006 | Jouets Et Ours |
  |    1002 | LT Supplies    |
  |   10002 | Mouse House    |
  |   10003 | Wascals        |
  |   10004 | Yosemite Place |
  +---------+----------------+
  10 rows in set (0.01 sec)
  ```



### 8.2 查询表中所有字段的值

- 语法：select * from 表名;  这是的*表示所有字段。

- 举例：

  ```sql
  #查询所有订单信息
  mysql> select * from orders;
  +-----------+---------------------+---------+
  | order_num | order_date          | cust_id |
  +-----------+---------------------+---------+
  |     20005 | 2005-09-01 00:00:00 |   10001 |
  |     20006 | 2005-09-12 00:00:00 |   10003 |
  |     20007 | 2005-09-30 00:00:00 |   10004 |
  |     20008 | 2005-10-03 00:00:00 |   10005 |
  |     20009 | 2005-10-08 00:00:00 |   10001 |
  |     20010 | 2005-11-08 01:00:00 |   10001 |
  |     20011 | 2005-11-08 00:00:00 |   10002 |
  +-----------+---------------------+---------+
  7 rows in set (0.00 sec)
  ```



### 8.3 对查询的结果去重

- 语法：

  - select distinct 字段1 from 表名;
  - select distinct 字段1,字段2 from 表名;    #表示对两个字段的组合去重

- 举例：

  ```sql
  #查询所有下过订单的客户ID
  mysql> select distinct cust_id from orders;
  +---------+
  | cust_id |
  +---------+
  |   10001 |
  |   10002 |
  |   10003 |
  |   10004 |
  |   10005 |
  +---------+
  5 rows in set (0.00 sec)



### 8.4 设定查询结果返回的行数

- 语法：

  - 格式一：select * from 表名 limit n,m; 

      说明：当limit后面跟两个参数时，第一个参数为偏移量，第二个参数为返回的行数，意思是从行号为n的行开始的后面m行；MySQL中的行号是从0开始计算的，limit 2,3是第3行开始往后数3行，也就是第3，4，5行。

  - 格式二：select * from 表名 limit m; 

    说明：当limit后面跟一个参数时，表示返回的行数，从第1行开始计算，可以理解成此时的偏移量是0，比如limit 3是指前三行
  
- 举例：

  ```sql
  #查询订单表中的数据，返回从3行（行号为2）开始的4行
  mysql> select * from orders limit 2,4;
  +-----------+---------------------+---------+
  | order_num | order_date          | cust_id |
  +-----------+---------------------+---------+
  |     20007 | 2005-09-30 00:00:00 |   10004 |
  |     20008 | 2005-10-03 00:00:00 |   10005 |
  |     20009 | 2005-10-08 00:00:00 |   10001 |
  |     20010 | 2005-11-08 01:00:00 |   10001 |
  +-----------+---------------------+---------+
  4 rows in set (0.00 sec)
  
  #查询订单表中的前2行数据
  mysql> select * from orders limit 2;
  +-----------+---------------------+---------+
  | order_num | order_date          | cust_id |
  +-----------+---------------------+---------+
  |     20005 | 2005-09-01 00:00:00 |   10001 |
  |     20006 | 2005-09-12 00:00:00 |   10003 |
  +-----------+---------------------+---------+
  2 rows in set (0.00 sec)
  ```



### 8.5 查询结果排序

- 语法：
  - select *  from 表名 order by 字段 [asc|desc]; 	注：asc表示升序，desc表示降序，如果不写关键字默认是升序
  - select *  from 表名 order by 字段1 [asc|desc], 字段2 asc|desc;    表示先按字段1排序，在字段1相同的情况下再按字段2排序
  
- 举例：

  ```sql
  #查询所有订单信息，按订单编号升序排列
  mysql> select * from orders order by order_num asc;
  +-----------+---------------------+---------+
  | order_num | order_date          | cust_id |
  +-----------+---------------------+---------+
  |     20005 | 2005-09-01 00:00:00 |   10001 |
  |     20006 | 2005-09-12 00:00:00 |   10003 |
  |     20007 | 2005-09-30 00:00:00 |   10004 |
  |     20008 | 2005-10-03 00:00:00 |   10005 |
  |     20009 | 2005-10-08 00:00:00 |   10001 |
  |     20010 | 2005-11-08 01:00:00 |   10001 |
  |     20011 | 2005-11-08 00:00:00 |   10002 |
  +-----------+---------------------+---------+
  7 rows in set (0.00 sec)
  
  #查询所有订单信息，按订单编号降序排列
  mysql> select * from orders order by order_num desc;
  +-----------+---------------------+---------+
  | order_num | order_date          | cust_id |
  +-----------+---------------------+---------+
  |     20011 | 2005-11-08 00:00:00 |   10002 |
  |     20010 | 2005-11-08 01:00:00 |   10001 |
  |     20009 | 2005-10-08 00:00:00 |   10001 |
  |     20008 | 2005-10-03 00:00:00 |   10005 |
  |     20007 | 2005-09-30 00:00:00 |   10004 |
  |     20006 | 2005-09-12 00:00:00 |   10003 |
  |     20005 | 2005-09-01 00:00:00 |   10001 |
  +-----------+---------------------+---------+
  7 rows in set (0.00 sec)
  
  #查询所有订单信息，按客户ID升序排列，客户ID相同的情况下按订单编号降序排列
  mysql> select * from orders order by cust_id asc, order_num desc;
  +-----------+---------------------+---------+
  | order_num | order_date          | cust_id |
  +-----------+---------------------+---------+
  |     20010 | 2005-11-08 01:00:00 |   10001 |
  |     20009 | 2005-10-08 00:00:00 |   10001 |
  |     20005 | 2005-09-01 00:00:00 |   10001 |
  |     20011 | 2005-11-08 00:00:00 |   10002 |
  |     20006 | 2005-09-12 00:00:00 |   10003 |
  |     20007 | 2005-09-30 00:00:00 |   10004 |
  |     20008 | 2005-10-03 00:00:00 |   10005 |
  +-----------+---------------------+---------+
  7 rows in set (0.00 sec)
  ```
  
  

### 8.6 使用order by和limit的组合，能够找出一个列中最高或者最低的值

- 语法：select 字段 from 表名 order by 字段 asc|desc limit 1;

- 举例：

  ```sql
  #查询产品的最高价格
  mysql> select prod_price from products order by prod_price desc limit 1;
  +------------+
  | prod_price |
  +------------+
  |      55.00 |
  +------------+
  1 row in set (0.00 sec)
  
  #查询产品的最低价格
  mysql> select prod_price from products order by prod_price asc limit 1;
  +------------+
  | prod_price |
  +------------+
  |       2.50 |
  +------------+
  1 row in set (0.00 sec)
  ```

- 注意：这种方式只能查出最高或最低的价格，不能查询最高或最低值的产品，因为可能有多个相同价格的产品。

  

### 8.7 随机查询一条数据

- 语法：select *  from 表名 order by rand() limit 1;

- 举例：

  ```sql
  #随机查询一个产品的信息
  mysql> select * from products order by rand() limit 1;
  +---------+---------+-----------+------------+---------------------+
  | prod_id | vend_id | prod_name | prod_price | prod_desc           |
  +---------+---------+-----------+------------+---------------------+
  | FU1     |    1002 | Fuses     |       3.42 | 1 dozen, extra long |
  +---------+---------+-----------+------------+---------------------+
  1 row in set (0.00 sec)
  ```

  

### 8.8 查询条件过滤

- 语法：select *  from 表名 where 条件;

- where子句中支持的操作符：

  | 操作符             | 说明                                                         |
  | ------------------ | ------------------------------------------------------------ |
  | =                  | 等于                                                         |
  | <>                 | 不等于                                                       |
  | !=                 | 不等于                                                       |
  | <                  | 小于                                                         |
  | <=                 | 小于等于                                                     |
  | >                  | 大于                                                         |
  | >=                 | 大于等于                                                     |
  | between...  and... | 在指定的两个值之间，包含边界                                 |
  | and                | 表示两个条件同时满足                                         |
  | or                 | 表示两个条件满足其中一个                                     |
  | in                 | 指定条件范围，范围内的每个条件都可以进行匹配。in取值包含在圆括号中，以逗号分隔 |
  | not                | 表示否定它之后所跟的任何条件，not一般跟in、is、between...and...组合起来用，not in, is not, not between...and... |
  | is                 | 举例：is null表示为空，is not null表示不为空                 |
  | like               | like后面跟通配符，表示查找模式利用通配符匹配而不是直接相等的匹配，MySQL中的通配符：%（任意多个任意字符）    _（一个任意字符） |

- 举例：

  ```sql
  #查询1001供应商供应的产品名称及价格?
  mysql> select prod_name,prod_price from products where vend_id=1001;
  +--------------+------------+
  | prod_name    | prod_price |
  +--------------+------------+
  | .5 ton anvil |       5.99 |
  | 1 ton anvil  |       9.99 |
  | 2 ton anvil  |      14.99 |
  +--------------+------------+
  3 rows in set (0.01 sec)
  
  #查询1001供应商之外的其它供应商供应的产品名称及价格?
  mysql> select prod_name,prod_price,vend_id from products where vend_id!=1001;
  +----------------+------------+---------+
  | prod_name      | prod_price | vend_id |
  +----------------+------------+---------+
  | Detonator      |      13.00 |    1003 |
  | Bird seed      |      10.00 |    1003 |
  | Carrots        |       2.50 |    1003 |
  | Fuses          |       3.42 |    1002 |
  | JetPack 1000   |      35.00 |    1005 |
  | JetPack 2000   |      55.00 |    1005 |
  | Oil can        |       8.99 |    1002 |
  | Safe           |      50.00 |    1003 |
  | Sling          |       4.49 |    1003 |
  | TNT (1 stick)  |       2.50 |    1003 |
  | TNT (5 sticks) |      10.00 |    1003 |
  +----------------+------------+---------+
  11 rows in set (0.00 sec)
  
  #查询产品价格高于5的产品ID和价格
  mysql> select prod_id,prod_price from products where prod_price>5;
  +---------+------------+
  | prod_id | prod_price |
  +---------+------------+
  | ANV01   |       5.99 |
  | ANV02   |       9.99 |
  | ANV03   |      14.99 |
  | DTNTR   |      13.00 |
  | FB      |      10.00 |
  | JP1000  |      35.00 |
  | JP2000  |      55.00 |
  | OL1     |       8.99 |
  | SAFE    |      50.00 |
  | TNT2    |      10.00 |
  +---------+------------+
  10 rows in set (0.01 sec)
  
  #查询产品价格介于5到10之间的产品ID和价格
  mysql> select prod_id,prod_price from products where prod_price between 5 and 10;
  +---------+------------+
  | prod_id | prod_price |
  +---------+------------+
  | ANV01   |       5.99 |
  | ANV02   |       9.99 |
  | FB      |      10.00 |
  | OL1     |       8.99 |
  | TNT2    |      10.00 |
  +---------+------------+
  5 rows in set (0.00 sec)
  
  #查询产品价格不在5到10之间的产品ID和价格
  mysql> select prod_id,prod_price from products where prod_price not between 5 and 10;
  +---------+------------+
  | prod_id | prod_price |
  +---------+------------+
  | ANV03   |      14.99 |
  | DTNTR   |      13.00 |
  | FC      |       2.50 |
  | FU1     |       3.42 |
  | JP1000  |      35.00 |
  | JP2000  |      55.00 |
  | SAFE    |      50.00 |
  | SLING   |       4.49 |
  | TNT1    |       2.50 |
  +---------+------------+
  9 rows in set (0.00 sec)
  
  #查询1003供应商供应的价格不在5到10之间的产品ID和价格
  mysql> select prod_id,prod_price,vend_id from products where vend_id=1003 and prod_price not between 5 and 10;
  +---------+------------+---------+
  | prod_id | prod_price | vend_id |
  +---------+------------+---------+
  | DTNTR   |      13.00 |    1003 |
  | FC      |       2.50 |    1003 |
  | SAFE    |      50.00 |    1003 |
  | SLING   |       4.49 |    1003 |
  | TNT1    |       2.50 |    1003 |
  +---------+------------+---------+
  5 rows in set (0.01 sec)
  
  #查询1001供应商的产品，以及价格介于10到20之间的产品（不分供应商）的名称及价格？
  mysql> select prod_name,prod_price,vend_id from products p where p.vend_id=1001 or p.prod_price between 10 and 20;
  +----------------+------------+---------+
  | prod_name      | prod_price | vend_id |
  +----------------+------------+---------+
  | .5 ton anvil   |       5.99 |    1001 |
  | 1 ton anvil    |       9.99 |    1001 |
  | 2 ton anvil    |      14.99 |    1001 |
  | Detonator      |      13.00 |    1003 |
  | Bird seed      |      10.00 |    1003 |
  | TNT (5 sticks) |      10.00 |    1003 |
  +----------------+------------+---------+
  6 rows in set (0.00 sec)
  
  #查询1001，1002,1003供应商的产品的名称及价格？
  mysql> select prod_name,prod_price,vend_id from products p where p.vend_id=1001 or p.vend_id=1002 or p.vend_id=1003;
  +----------------+------------+---------+
  | prod_name      | prod_price | vend_id |
  +----------------+------------+---------+
  | .5 ton anvil   |       5.99 |    1001 |
  | 1 ton anvil    |       9.99 |    1001 |
  | 2 ton anvil    |      14.99 |    1001 |
  | Detonator      |      13.00 |    1003 |
  | Bird seed      |      10.00 |    1003 |
  | Carrots        |       2.50 |    1003 |
  | Fuses          |       3.42 |    1002 |
  | Oil can        |       8.99 |    1002 |
  | Safe           |      50.00 |    1003 |
  | Sling          |       4.49 |    1003 |
  | TNT (1 stick)  |       2.50 |    1003 |
  | TNT (5 sticks) |      10.00 |    1003 |
  +----------------+------------+---------+
  12 rows in set (0.00 sec)
  #也可以使用IN来表示多个OR并列
  mysql> select prod_name,prod_price,vend_id from products p where p.vend_id in (1001,1002,1003);
  +----------------+------------+---------+
  | prod_name      | prod_price | vend_id |
  +----------------+------------+---------+
  | .5 ton anvil   |       5.99 |    1001 |
  | 1 ton anvil    |       9.99 |    1001 |
  | 2 ton anvil    |      14.99 |    1001 |
  | Detonator      |      13.00 |    1003 |
  | Bird seed      |      10.00 |    1003 |
  | Carrots        |       2.50 |    1003 |
  | Fuses          |       3.42 |    1002 |
  | Oil can        |       8.99 |    1002 |
  | Safe           |      50.00 |    1003 |
  | Sling          |       4.49 |    1003 |
  | TNT (1 stick)  |       2.50 |    1003 |
  | TNT (5 sticks) |      10.00 |    1003 |
  +----------------+------------+---------+
  12 rows in set (0.00 sec)
  
  #查询1001,1002,1003供应商之外的其它供应商的产品的名称及价格？
  mysql> select prod_name,prod_price,vend_id from products p where p.vend_id!=1001 and p.vend_id!=1002 and p.vend_id!=1003;
  +--------------+------------+---------+
  | prod_name    | prod_price | vend_id |
  +--------------+------------+---------+
  | JetPack 1000 |      35.00 |    1005 |
  | JetPack 2000 |      55.00 |    1005 |
  +--------------+------------+---------+
  2 rows in set (0.01 sec)
  #也可以使用not in来实现
  mysql> select prod_name,prod_price,vend_id from products p where p.vend_id not in (1001,1002,1003);
  +--------------+------------+---------+
  | prod_name    | prod_price | vend_id |
  +--------------+------------+---------+
  | JetPack 1000 |      35.00 |    1005 |
  | JetPack 2000 |      55.00 |    1005 |
  +--------------+------------+---------+
  2 rows in set (0.00 sec)
  
  #查询邮箱地址为空的客户信息
  mysql> select * from customers c where c.cust_email is null;
  +---------+-------------+------------------+-----------+------------+----------+--------------+--------------+------------+
  | cust_id | cust_name   | cust_address     | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email |
  +---------+-------------+------------------+-----------+------------+----------+--------------+--------------+------------+
  |   10002 | Mouse House | 333 Fromage Lane | Columbus  | OH         | 43333    | USA          | Jorry Mouse  | NULL       |
  |   10005 | E Fudd      | 4545 53rd Street | Chicago   | IL         | 54545    | USA          | E Fudd       | NULL       |
  +---------+-------------+------------------+-----------+------------+----------+--------------+--------------+------------+
  2 rows in set (0.00 sec)
  
  #查询邮箱地址不为空的客户信息
  mysql> select * from customers c where c.cust_email is not null;
  +---------+----------------+---------------------+-----------+------------+----------+--------------+--------------+---------------------+
  | cust_id | cust_name      | cust_address        | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email          |
  +---------+----------------+---------------------+-----------+------------+----------+--------------+--------------+---------------------+
  |   10001 | Coyote Inc.    | 200 Maple Lane      | Detroit   | MI         | 44444    | USA          | Y Lee        | ylee@coyote.com     |
  |   10003 | Wascals        | 1 Sunny Lane Place  | Muncie    | IN         | 42222    | USA          | Jim Jones    | rabbit@wascally.com |
  |   10004 | Yosemite Place | 829 Riverside Drive | Phoenix   | AZ         | 88888    | USA          | Y Sam        | sam@yosemite.com    |
  +---------+----------------+---------------------+-----------+------------+----------+--------------+--------------+---------------------+
  3 rows in set (0.00 sec)
  ```

- 通配符举例：

  ```sql
  #查询产品名称以JetPack开头的产品信息
  mysql> SELECT * FROM PRODUCTS WHERE PROD_NAME LIKE "JetPack%";
  +---------+---------+--------------+------------+---------------------------------------+
  | prod_id | vend_id | prod_name    | prod_price | prod_desc                             |
  +---------+---------+--------------+------------+---------------------------------------+
  | JP1000  |    1005 | JetPack 1000 |      35.00 | JetPack 1000, intended for single use |
  | JP2000  |    1005 | JetPack 2000 |      55.00 | JetPack 2000, multi-use               |
  +---------+---------+--------------+------------+---------------------------------------+
  2 rows in set (0.00 sec)
  
  #查询客户联系人是以Y开头的客户的信息
  mysql> select * from customers c where c.cust_contact like "Y%";
  +---------+----------------+---------------------+-----------+------------+----------+--------------+--------------+------------------+
  | cust_id | cust_name      | cust_address        | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email       |
  +---------+----------------+---------------------+-----------+------------+----------+--------------+--------------+------------------+
  |   10001 | Coyote Inc.    | 200 Maple Lane      | Detroit   | MI         | 44444    | USA          | Y Lee        | ylee@coyote.com  |
  |   10004 | Yosemite Place | 829 Riverside Drive | Phoenix   | AZ         | 88888    | USA          | Y Sam        | sam@yosemite.com |
  +---------+----------------+---------------------+-----------+------------+----------+--------------+--------------+------------------+
  2 rows in set (0.00 sec)
  
  #查询客户联系人是以e结尾的客户的信息
  mysql> select * from customers c where c.cust_contact like "%e";
  +---------+-------------+------------------+-----------+------------+----------+--------------+--------------+-----------------+
  | cust_id | cust_name   | cust_address     | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email      |
  +---------+-------------+------------------+-----------+------------+----------+--------------+--------------+-----------------+
  |   10001 | Coyote Inc. | 200 Maple Lane   | Detroit   | MI         | 44444    | USA          | Y Lee        | ylee@coyote.com |
  |   10002 | Mouse House | 333 Fromage Lane | Columbus  | OH         | 43333    | USA          | Jorry Mouse  | NULL            |
  +---------+-------------+------------------+-----------+------------+----------+--------------+--------------+-----------------+
  2 rows in set (0.00 sec)
  
  #查询客户联系人包含e的客户的信息
  mysql> select * from customers c where c.cust_contact like "%e%";
  +---------+-------------+--------------------+-----------+------------+----------+--------------+--------------+---------------------+
  | cust_id | cust_name   | cust_address       | cust_city | cust_state | cust_zip | cust_country | cust_contact | cust_email          |
  +---------+-------------+--------------------+-----------+------------+----------+--------------+--------------+---------------------+
  |   10001 | Coyote Inc. | 200 Maple Lane     | Detroit   | MI         | 44444    | USA          | Y Lee        | ylee@coyote.com     |
  |   10002 | Mouse House | 333 Fromage Lane   | Columbus  | OH         | 43333    | USA          | Jorry Mouse  | NULL                |
  |   10003 | Wascals     | 1 Sunny Lane Place | Muncie    | IN         | 42222    | USA          | Jim Jones    | rabbit@wascally.com |
  |   10005 | E Fudd      | 4545 53rd Street   | Chicago   | IL         | 54545    | USA          | E Fudd       | NULL                |
  +---------+-------------+--------------------+-----------+------------+----------+--------------+--------------+---------------------+
  4 rows in set (0.00 sec)
  
  #查询姓王的客户信息
  select * from customers c where c.cust_name like "王%";
  ```

- 通配符使用注意事项：

  - %与\_的区别：%表示任意多个任意字符，_表示匹配一个字符，不能多也不能少；
  - 使用通配符会比没有通配符更消耗数据库执行查询的时间，应该在需要使用通配符的地方才使用。



## 9. MySQL的函数

**思路：在函数这里，部分同学会绕不过来，因为前面的select查询都是从表中查某个字段，字段的值是多少查出来就是多少；但是从函数这里开始，查出来的结果是通过函数去计算表中的某个字段的结果，也有可能不是从表中去查的。函数可以用到select后面，也可以用到where后面作为条件。**

### 9.1 聚集函数（重点）

- 聚集函数：聚集函数是在列上的运算，比如找这一列的最大、最小、平均、求和、统计行数等。

- avg()

  - 作用：返回某列的平均值 

  - 举例：

    ```sql
    #计算产品的平均价格
    mysql> select avg(prod_price) from products;
    +-----------------+
    | avg(prod_price) |
    +-----------------+
    |       16.133571 |
    +-----------------+
    1 row in set (0.00 sec)
    ```

- count()

  - 作用：返回某列的行数，注意：count统计的是某个列上非空的行的数量，如果某一行是null，就不会被统计在内，在实际使用中如果要统计表的行数，直接用count(*)，只要行上有一个字段非null，就会被统计在内。

  - 举例：

    ```sql
    #统计产品的数量
    mysql> select count(*) from products;
    +----------+
    | count(*) |
    +----------+
    |       14 |
    +----------+
    1 row in set (0.00 sec)
    ```

- max()

  - 作用：返回某列的最大值

  - 举例：

    ```sql
    #统计产品的最高价
    mysql> select max(prod_price) from products;
    +-----------------+
    | max(prod_price) |
    +-----------------+
    |           55.00 |
    +-----------------+
    1 row in set (0.00 sec)
    ```

- min()

  - 作用：返回某列的最小值

  - 举例：

    ```sql
    #统计产品的最低价
    mysql> select min(prod_price) from products;
    +-----------------+
    | min(prod_price) |
    +-----------------+
    |            2.50 |
    +-----------------+
    1 row in set (0.00 sec)
    ```

- sum() 

  - 作用：返回某列值之和

  - 举例：

    ```sql
    #统计产品单价的总和
    mysql> select sum(prod_price) from products;
    +-----------------+
    | sum(prod_price) |
    +-----------------+
    |          225.87 |
    +-----------------+
    1 row in set (0.00 sec)
    ```



### 9.2 日期与时间函数（重点）

- curdate()

  - 作用：返回系统当前日期

  - 举例：

    ```sql
    mysql> select curdate();
    +------------+
    | curdate()  |
    +------------+
    | 2021-07-09 |
    +------------+
    1 row in set (0.00 sec)
    ```

- curtime()

  - 作用：返回当前时间

  - 举例：

    ```sql
    mysql> select curtime();
    +-----------+
    | curtime() |
    +-----------+
    | 15:03:48  |
    +-----------+
    1 row in set (0.00 sec)
    ```

- now()

  - 作用：返回当前日期和时间

  - 举例：

    ```sql
    mysql> select now();
    +---------------------+
    | now()               |
    +---------------------+
    | 2021-07-09 15:04:03 |
    +---------------------+
    1 row in set (0.00 sec)
    ```

- adddate()

  - 作用：增加一个日期（天、周、月、年等）

  - 举例：

    ```sql
    #计算订单下单日期之后30天的日期
    mysql> select cust_id,order_num,order_date,adddate(order_date, interval 30 day) from orders;
    +---------+-----------+---------------------+--------------------------------------+
    | cust_id | order_num | order_date          | adddate(order_date, interval 30 day) |
    +---------+-----------+---------------------+--------------------------------------+
    |   10001 |     20005 | 2005-09-01 00:00:00 | 2005-10-01 00:00:00                  |
    |   10003 |     20006 | 2005-09-12 00:00:00 | 2005-10-12 00:00:00                  |
    |   10004 |     20007 | 2005-09-30 00:00:00 | 2005-10-30 00:00:00                  |
    |   10005 |     20008 | 2005-10-03 00:00:00 | 2005-11-02 00:00:00                  |
    |   10001 |     20009 | 2005-10-08 00:00:00 | 2005-11-07 00:00:00                  |
    |   10001 |     20010 | 2005-11-08 01:00:00 | 2005-12-08 01:00:00                  |
    |   10002 |     20011 | 2005-11-08 00:00:00 | 2005-12-08 00:00:00                  |
    +---------+-----------+---------------------+--------------------------------------+
    7 rows in set (0.00 sec)
    
    #计算订单下单日期之后1周的日期
    mysql> select cust_id,order_num,order_date,adddate(order_date, interval 1 week) from orders;
    +---------+-----------+---------------------+--------------------------------------+
    | cust_id | order_num | order_date          | adddate(order_date, interval 1 week) |
    +---------+-----------+---------------------+--------------------------------------+
    |   10001 |     20005 | 2005-09-01 00:00:00 | 2005-09-08 00:00:00                  |
    |   10003 |     20006 | 2005-09-12 00:00:00 | 2005-09-19 00:00:00                  |
    |   10004 |     20007 | 2005-09-30 00:00:00 | 2005-10-07 00:00:00                  |
    |   10005 |     20008 | 2005-10-03 00:00:00 | 2005-10-10 00:00:00                  |
    |   10001 |     20009 | 2005-10-08 00:00:00 | 2005-10-15 00:00:00                  |
    |   10001 |     20010 | 2005-11-08 01:00:00 | 2005-11-15 01:00:00                  |
    |   10002 |     20011 | 2005-11-08 00:00:00 | 2005-11-15 00:00:00                  |
    +---------+-----------+---------------------+--------------------------------------+
    7 rows in set (0.00 sec)
    
    #计算订单下单日期之后1个月的日期
    mysql> select cust_id,order_num,order_date,adddate(order_date, interval 1 month) from orders;
    +---------+-----------+---------------------+---------------------------------------+
    | cust_id | order_num | order_date          | adddate(order_date, interval 1 month) |
    +---------+-----------+---------------------+---------------------------------------+
    |   10001 |     20005 | 2005-09-01 00:00:00 | 2005-10-01 00:00:00                   |
    |   10003 |     20006 | 2005-09-12 00:00:00 | 2005-10-12 00:00:00                   |
    |   10004 |     20007 | 2005-09-30 00:00:00 | 2005-10-30 00:00:00                   |
    |   10005 |     20008 | 2005-10-03 00:00:00 | 2005-11-03 00:00:00                   |
    |   10001 |     20009 | 2005-10-08 00:00:00 | 2005-11-08 00:00:00                   |
    |   10001 |     20010 | 2005-11-08 01:00:00 | 2005-12-08 01:00:00                   |
    |   10002 |     20011 | 2005-11-08 00:00:00 | 2005-12-08 00:00:00                   |
    +---------+-----------+---------------------+---------------------------------------+
    7 rows in set (0.00 sec)
    
    #计算订单下单日期之后1年的日期
    mysql> select cust_id,order_num,order_date,adddate(order_date, interval 1 year) from orders;
    +---------+-----------+---------------------+--------------------------------------+
    | cust_id | order_num | order_date          | adddate(order_date, interval 1 year) |
    +---------+-----------+---------------------+--------------------------------------+
    |   10001 |     20005 | 2005-09-01 00:00:00 | 2006-09-01 00:00:00                  |
    |   10003 |     20006 | 2005-09-12 00:00:00 | 2006-09-12 00:00:00                  |
    |   10004 |     20007 | 2005-09-30 00:00:00 | 2006-09-30 00:00:00                  |
    |   10005 |     20008 | 2005-10-03 00:00:00 | 2006-10-03 00:00:00                  |
    |   10001 |     20009 | 2005-10-08 00:00:00 | 2006-10-08 00:00:00                  |
    |   10001 |     20010 | 2005-11-08 01:00:00 | 2006-11-08 01:00:00                  |
    |   10002 |     20011 | 2005-11-08 00:00:00 | 2006-11-08 00:00:00                  |
    +---------+-----------+---------------------+--------------------------------------+
    7 rows in set (0.00 sec)
    
    #查询20006和20005两个订单之间的间隔天数
    mysql> select date(a.order_date)-date(b.order_date) from (select order_date from orders where order_num=20006) as a, (selecct order_date from orders where order_num=20005) as b;
    +---------------------------------------+
    | date(a.order_date)-date(b.order_date) |
    +---------------------------------------+
    |                                    11 |
    +---------------------------------------+
    1 row in set (0.00 sec)
    ```

- addtime()

  - 作用：增加一个时间（时、分、秒等）

  - 举例：

    ```sql
    #计算订单时间之后的30分钟的时间
    mysql> select *,addtime(order_date,"00:30:00") from orders;
    +-----------+---------------------+---------+--------------------------------+
    | order_num | order_date          | cust_id | addtime(order_date,"00:30:00") |
    +-----------+---------------------+---------+--------------------------------+
    |     20005 | 2005-09-01 00:00:00 |   10001 | 2005-09-01 00:30:00            |
    |     20006 | 2005-09-12 00:00:00 |   10003 | 2005-09-12 00:30:00            |
    |     20007 | 2005-09-30 00:00:00 |   10004 | 2005-09-30 00:30:00            |
    |     20008 | 2005-10-03 00:00:00 |   10005 | 2005-10-03 00:30:00            |
    |     20009 | 2005-10-08 00:00:00 |   10001 | 2005-10-08 00:30:00            |
    |     20010 | 2005-11-08 01:00:00 |   10001 | 2005-11-08 01:30:00            |
    |     20011 | 2005-11-08 00:00:00 |   10002 | 2005-11-08 00:30:00            |
    +-----------+---------------------+---------+--------------------------------+
    7 rows in set (0.00 sec)
    ```
  
- date()

  - 作用：返回日期时间的日期部分

  - 举例：

    ```sql
    #查询2005-11-08号的订单信息
    mysql> select * from orders where date(order_date)="2005-11-08";
    +-----------+---------------------+---------+
    | order_num | order_date          | cust_id |
    +-----------+---------------------+---------+
    |     20010 | 2005-11-08 01:00:00 |   10001 |
    |     20011 | 2005-11-08 00:00:00 |   10002 |
    +-----------+---------------------+---------+
    2 rows in set (0.00 sec)
    ```
  
- year()

  - 作用：返回日期时间的年的部分

  - 举例：

    ```sql
    #查询2005年的订单信息
    mysql> select * from orders where year(order_date)="2005";
    +-----------+---------------------+---------+
    | order_num | order_date          | cust_id |
    +-----------+---------------------+---------+
    |     20005 | 2005-09-01 00:00:00 |   10001 |
    |     20006 | 2005-09-12 00:00:00 |   10003 |
    |     20007 | 2005-09-30 00:00:00 |   10004 |
    |     20008 | 2005-10-03 00:00:00 |   10005 |
    |     20009 | 2005-10-08 00:00:00 |   10001 |
    |     20010 | 2005-11-08 01:00:00 |   10001 |
    |     20011 | 2005-11-08 00:00:00 |   10002 |
    +-----------+---------------------+---------+
    7 rows in set (0.00 sec)
    ```
  
- month()

  - 作用：返回日期时间的月的部分

  - 举例：

    ```sql
    #查询2005年9月的订单信息
    mysql> select * from orders where year(order_date)="2005" and month(order_date)=9;
    +-----------+---------------------+---------+
    | order_num | order_date          | cust_id |
    +-----------+---------------------+---------+
    |     20005 | 2005-09-01 00:00:00 |   10001 |
    |     20006 | 2005-09-12 00:00:00 |   10003 |
    |     20007 | 2005-09-30 00:00:00 |   10004 |
    +-----------+---------------------+---------+
    3 rows in set (0.00 sec)
    ```
  
- day()

  - 作用：返回日期时间的天的部分

  - 举例：

    ```sql
    #查询2005年9月30号的订单信息
    mysql> select * from orders where year(order_date)="2005" and month(order_date)=9 and day(order_date)=30;
    +-----------+---------------------+---------+
    | order_num | order_date          | cust_id |
    +-----------+---------------------+---------+
    |     20007 | 2005-09-30 00:00:00 |   10004 |
    +-----------+---------------------+---------+
    1 row in set (0.00 sec)
    ```
    
    

### 9.3 数值处理函数

- round(x,y)

  - 作用：对x四舍五入保留y位小数

  - 举例：

    ```sql
    mysql> select prod_price,round(prod_price,1) from products;
    +------------+---------------------+
    | prod_price | round(prod_price,1) |
    +------------+---------------------+
    |       5.99 |                 6.0 |
    |       9.99 |                10.0 |
    |      14.99 |                15.0 |
    |      13.00 |                13.0 |
    |      10.00 |                10.0 |
    |       2.50 |                 2.5 |
    |       3.42 |                 3.4 |
    |      35.00 |                35.0 |
    |      55.00 |                55.0 |
    |       8.99 |                 9.0 |
    |      50.00 |                50.0 |
    |       4.49 |                 4.5 |
    |       2.50 |                 2.5 |
    |      10.00 |                10.0 |
    +------------+---------------------+
    14 rows in set (0.00 sec)
    ```

- truncate(x,y)

  - 作用：对x截断保留y位小数

  - 举例：

    ```sql
    mysql> select prod_price,truncate(prod_price,1) from products;
    +------------+------------------------+
    | prod_price | truncate(prod_price,1) |
    +------------+------------------------+
    |       5.99 |                    5.9 |
    |       9.99 |                    9.9 |
    |      14.99 |                   14.9 |
    |      13.00 |                   13.0 |
    |      10.00 |                   10.0 |
    |       2.50 |                    2.5 |
    |       3.42 |                    3.4 |
    |      35.00 |                   35.0 |
    |      55.00 |                   55.0 |
    |       8.99 |                    8.9 |
    |      50.00 |                   50.0 |
    |       4.49 |                    4.4 |
    |       2.50 |                    2.5 |
    |      10.00 |                   10.0 |
    +------------+------------------------+
    14 rows in set (0.00 sec)
    ```

- abs(x)

  - 作用：返回x的绝对值

  - 举例：

    ```sql
    mysql> select abs(-1);
    +---------+
    | abs(-1) |
    +---------+
    |       1 |
    +---------+
    1 row in set (0.00 sec)
    ```

- rand()

  - 作用：返回0~1内的随机值

  - 举例：

    ```sql
    mysql> select rand();
    +--------------------+
    | rand()             |
    +--------------------+
    | 0.3681343555153668 |
    +--------------------+
    1 row in set (0.00 sec)
    ```

    

### 9.4 系统函数

- version()

  - 作用：返回数据库版本号

  - 举例：

    ```sql
    mysql> select version();
    +------------+
    | version()  |
    +------------+
    | 5.6.37-log |
    +------------+
    1 row in set (0.00 sec)
    ```

- database()

  - 作用：返回当前连接的数据库

  - 举例：

    ```sql
    mysql> select database();
    +-------------+
    | database()  |
    +-------------+
    | crashcourse |
    +-------------+
    1 row in set (0.00 sec)
    ```

- user()

  - 作用：返回当前登录的用户

  - 举例：

    ```python
    mysql> select user();
    +----------------+
    | user()         |
    +----------------+
    | root@localhost |
    +----------------+
    1 row in set (0.00 sec)
    ```

    

## 10. 分组查询

**思路：重点要讲明白什么情况下需要用到分组，多举例子，有些学生自己在写的时候反应不过来要用到分组；还有就是什么情况用where过滤，什么情况用having过滤。**

### 10.1 分组查询

- 语法：在select语句中通过group by子句实现分组，通常在group by后面跟一个字段，字段值相同的行作为一组，通常分组的目的是为了对每个分组做聚集运算，在分组查询中，select后面只能跟group by后面的字段和聚集运算的结果。

- select 字段, 聚集函数 from 表 group by 字段;

- select 字段1, 字段2,聚集函数 from 表 group by 字段1, 字段2;

- 举例：

  ```sql
  #统计每个供应商供应的产品数量
  mysql> select vend_id,count(*) as 产品数量 from products group by vend_id;
  +---------+----------+
  | vend_id | 产品数量  |
  +---------+----------+
  |    1001 |        3 |
  |    1002 |        2 |
  |    1003 |        7 |
  |    1005 |        2 |
  +---------+----------+
  4 rows in set (0.01 sec)
  ```
  
- 注意：

  1）select后面只能查看group by子句后有的列以及聚集运算的结果；

  2）group by可以根据多个列进行分组，多个列分组即对多个列的组合值相同的进行分组；

- 课堂练习：
  - 1、统计2005年每月的订单数量？
  - 2、统计2005年每个客户的订单数量？

### 10.2 过滤分组

- 语法：通过having子句实现分组的过滤

- 举例：

  ```sql
  #统计供应了2种以上产品的供应商id及产品数量
  mysql> select vend_id,count(*) as 产品数量 from products group by vend_id having count(*)>2;
  +---------+--------------+
  | vend_id | 产品数量     |
  +---------+--------------+
  |    1001 |            3 |
  |    1003 |            7 |
  +---------+--------------+
  2 rows in set (0.00 sec)
  ```



### 10.3 过滤行与过滤分组的区别

- 语法：过滤行是在分组前用where来实现，得到的是满足条件的所有行；过滤分组是在分组后通过having来实现，得到的是满足条件的所有分组。

- 举例：

  ```sql
  #统计供应了2种以上价格大于5的产品的供应商id及产品数量（价格大于5通过WHERE过滤，数量大于2通过HAVING过滤）
  mysql> select vend_id,count(*) as 产品数量 from products where prod_price>5 group by vend_id having count(*)>2;
  +---------+--------------+
  | vend_id | 产品数量     |
  +---------+--------------+
  |    1001 |            3 |
  |    1003 |            4 |
  +---------+--------------+
  2 rows in set (0.01 sec)
  ```


### 10.4 分组查询的使用场景

当需要按某个维度去做聚集运算时，通常会用到分组查询。比如统计每个客户的订单数量，每个供应商的产品数量，每个供应商产品的最高、最低、平均价，每个学生的总分，每门课程的平均分等，都需要用到分组查询。

分组查询通常和聚集运算结合在一起使用。



## 11. select查询中子句的执行顺序

select语句中使用的子句必须按照一定的次序，下图列出来各个子句在select语句中出现的次序

| **子句** | **说明**           | **是否必须使用**       |
| -------- | ------------------ | ---------------------- |
| select   | 要返回的列或表达式 | 是                     |
| from     | 从中检索数据的表   | 仅在从表选择数据时使用 |
| where    | 行级过滤           | 否                     |
| group by | 分组说明           | 仅在按组计算聚集时使用 |
| having   | 组级过滤           | 否                     |
| order by | 输出排序顺序       | 否                     |
| limit    | 要检索的行数       | 否                     |



## 12. 子查询

- 在查询中嵌套查询，用IN实现嵌套，里面的查询的返回值作为外面查询的条件。

- 语法：select * from 表 where 字段 in (select 字段 from 表);

- 举例：

```sql
#例1：查询名称为ACME供应商供应的产品名称？
#方法1：
#先在供应商表中查出ACME供应商的编号
mysql> select v.vend_id from vendors v where v.vend_name="ACME";
+---------+
| vend_id |
+---------+
|    1003 |
+---------+
1 row in set (0.00 sec)
#再根据供应商编号在产品表中查出产品名称
mysql> select p.prod_name from products p where p.vend_id in (1003);
+----------------+
| prod_name      |
+----------------+
| Detonator      |
| Bird seed      |
| Carrots        |
| Safe           |
| Sling          |
| TNT (1 stick)  |
| TNT (5 sticks) |
+----------------+
7 rows in set (0.00 sec)

#方法2：用子查询实现，把第一个查询嵌套到第二个查询语句中，第一个查询的返回作为第二个查询的条件
select p.prod_name from products p where p.vend_id in (select v.vend_id from vendors v where v.vend_name="ACME");


#例2：查询购买了编号为TNT2的产品的所有客户姓名
#方法1：
#先查找包含物品TNT2的所有订单的编号
mysql> select order_num from orderitems where prod_id='TNT2';
+-----------+
| order_num |
+-----------+
|     20005 |
|     20007 |
+-----------+
2 rows in set (0.01 sec)
#再查找前一步骤列出的订单编号的所有客户的ID
mysql> select cust_id from orders where order_num in (20005,20007);
+---------+
| cust_id |
+---------+
|   10001 |
|   10004 |
+---------+
2 rows in set (0.00 sec)
#最后再查找前一步列出的客户ID的客户姓名及其他信息
mysql> select cust_id,cust_name from customers where cust_id in (10001,10004);
+---------+----------------+
| cust_id | cust_name      |
+---------+----------------+
|   10001 | Coyote Inc.    |
|   10004 | Yosemite Place |
+---------+----------------+
2 rows in set (0.00 sec)

#方法2：用子查询实现
mysql> select cust_id,cust_name from customers where cust_id in (select cust_id from orders where order_num in (select order_num from orderitems where prod_id = 'TNT2'));
+---------+----------------+
| CUST_ID | CUST_NAME      |
+---------+----------------+
|   10001 | Coyote Inc.    |
|   10004 | Yosemite Place |
+---------+----------------+
2 rows in set (0.01 sec)
```



## 13. 连表查询

**思路：讲清楚三种连表的计算规则、区别，怎么指定正确的连表条件。**

### 13.1 内连接

- 为什么要连表？

  - 关系型数据库的特点就是分表存放数据，把一类的数据放在一张表中，但实际使用时，很多时候需要把不同表中的数据查到一个结果中，这就需要用到连表查询，这也是SQL最强大的功能之一。

- 语法：
  
  -  select * from 表1 inner join 表2 on 条件;  inner可以省略
  -  select * from 表1, 表2 where 条件；
  - 说明：以上两种写法都成立，不管哪种写法，需要注意的是都需要指定连接条件，如果不指定连接条件，会导致第一张表中的每一行跟第二张表的每一行组合，最终得到一个笛卡尔乘积。
  
- 计算规则：两张表连连接，用左边表的每一行去匹配右边表的每一行，如果满足连接的条件，就组成一行返回，返回的行里面包括两张表的所有字段，如果不满足连接的条件，就不返回。

- 举例：

  ```sql
  #1）查询各个供应商的产品名称和价格，按供应商名称和产品名称升序排列（用WHERE指定连接条件）
  mysql> select vend_name,prod_name,prod_price from vendors,products where vendors.vend_id=products.vend_id order by vend_name,prod_name;
  +-------------+----------------+------------+
  | vend_name   | prod_name      | prod_price |
  +-------------+----------------+------------+
  | ACME        | Bird seed      |      10.00 |
  | ACME        | Carrots        |       2.50 |
  | ACME        | Detonator      |      13.00 |
  | ACME        | Safe           |      50.00 |
  | ACME        | Sling          |       4.49 |
  | ACME        | TNT (1 stick)  |       2.50 |
  | ACME        | TNT (5 sticks) |      10.00 |
  | Anvils R Us | .5 ton anvil   |       5.99 |
  | Anvils R Us | 1 ton anvil    |       9.99 |
  | Anvils R Us | 2 ton anvil    |      14.99 |
  | Jet Set     | JetPack 1000   |      35.00 |
  | Jet Set     | JetPack 2000   |      55.00 |
  | LT Supplies | Fuses          |       3.42 |
  | LT Supplies | Oil can        |       8.99 |
  +-------------+----------------+------------+
  14 rows in set (0.01 sec)
  
  #2）查询各个供应商的产品名称和价格，按供应商名称和产品名称升序排列（用INNER JOIN结构）
  mysql> select vend_name,prod_name,prod_price from vendors inner join products on vendors.vend_id=products.vend_id order by vend_name,prod_name;
  +-------------+----------------+------------+
  | VEND_NAME   | PROD_NAME      | PROD_PRICE |
  +-------------+----------------+------------+
  | ACME        | Bird seed      |      10.00 |
  | ACME        | Carrots        |       2.50 |
  | ACME        | Detonator      |      13.00 |
  | ACME        | Safe           |      50.00 |
  | ACME        | Sling          |       4.49 |
  | ACME        | TNT (1 stick)  |       2.50 |
  | ACME        | TNT (5 sticks) |      10.00 |
  | Anvils R Us | .5 ton anvil   |       5.99 |
  | Anvils R Us | 1 ton anvil    |       9.99 |
  | Anvils R Us | 2 ton anvil    |      14.99 |
  | Jet Set     | JetPack 1000   |      35.00 |
  | Jet Set     | JetPack 2000   |      55.00 |
  | LT Supplies | Fuses          |       3.42 |
  | LT Supplies | Oil can        |       8.99 |
  +-------------+----------------+------------+
  14 rows in set (0.00 sec)
  
  #3）查询被购买过的产品名称、订单编号、购买数量
  mysql> select prod_name,o.order_num,quantity from products p inner join orderitems o on p.prod_id=o.prod_id;
  +----------------+-----------+----------+
  | prod_name      | order_num | quantity |
  +----------------+-----------+----------+
  | .5 ton anvil   |     20005 |       10 |
  | 1 ton anvil    |     20005 |        3 |
  | TNT (5 sticks) |     20005 |        5 |
  | Bird seed      |     20005 |        1 |
  | JetPack 2000   |     20006 |        1 |
  | TNT (5 sticks) |     20007 |      100 |
  | Carrots        |     20008 |       50 |
  | Bird seed      |     20009 |        1 |
  | Oil can        |     20009 |        1 |
  | Sling          |     20009 |        1 |
  | 2 ton anvil    |     20009 |        1 |
  +----------------+-----------+----------+
  11 rows in set (0.00 sec)
  ```

- 多表连接的数量：SQL中对一条select语句中可以连接的表的数目没有限制，如果有3张表连接，只需要A和B连接，再和C连接就可以了，依次类推......

  ```sql
  # 3张表连接举例：
  #查询订单编号为20005的订单中的物品信息（产品名称、供应商名称、产品价格、数量）
  mysql> select prod_name,vend_name,prod_price,quantity from orderitems,products,vendors where products.vend_id=vendors.vend_id and orderitems.prod_id=products.prod_id and orderitems.order_num=20005;
  +----------------+-------------+------------+----------+
  | PROD_NAME      | VEND_NAME   | PROD_PRICE | QUANTITY |
  +----------------+-------------+------------+----------+
  | .5 ton anvil   | Anvils R Us |       5.99 |       10 |
  | 1 ton anvil    | Anvils R Us |       9.99 |        3 |
  | TNT (5 sticks) | ACME        |      10.00 |        5 |
  | Bird seed      | ACME        |      10.00 |        1 |
  +----------------+-------------+------------+----------+
  4 rows in set (0.01 sec)
  
  # 4张表连接举例：
  #查询每个客户的姓名及购买的产品名称？
  mysql> select c.cust_name,p.prod_name from customers c inner join orders o on c.cust_id=o.cust_id inner join orderitems oi on o.order_num=oi.order_num inner join products p on oi.prod_id=p.prod_id;
  +----------------+----------------+
  | cust_name      | prod_name      |
  +----------------+----------------+
  | Coyote Inc.    | .5 ton anvil   |
  | Coyote Inc.    | 1 ton anvil    |
  | Coyote Inc.    | TNT (5 sticks) |
  | Coyote Inc.    | Bird seed      |
  | Coyote Inc.    | Bird seed      |
  | Coyote Inc.    | Oil can        |
  | Coyote Inc.    | Sling          |
  | Coyote Inc.    | 2 ton anvil    |
  | Wascals        | JetPack 2000   |
  | Yosemite Place | TNT (5 sticks) |
  | E Fudd         | Carrots        |
  +----------------+----------------+
  11 rows in set (0.00 sec)
  ```

- 两张表连接课堂练习：

  - 1、查询被购买过的产品名称、订单编号、购买数量
  - 2、查询被购买过的价格大于10的产品名称、订单编号、购买数量
  - 3、查询老师的姓名及教授的课程名称？
  - 4、查询名叫孙权的老师教授的课程名称？

- 三张表连接课堂练习：

  - 1、查询购买了TNT2产品的客户名称及订单编号？
  - 2、查询客户名称、订单编号及购买的产品名称？

### 13.2 外连接

- 外连接又分为左外连接和右外连接两种。

- 左外连接

  - 语法：select * from 表1 left join 表2 on 条件；

  - 计算规则：以左边表为基准，用左边表的每一行去匹配右边表的每一行，如果满足连接的条件，就组成一行返回，如果连接的字段只在左边表存在，在右边表不存在，那么在结果中就只显示左边表的字段，右边表中不存在的字段用空值NULL来表示。

  - 举例：

    ```sql
    #1）统计每个客户下了哪些订单，包括那些至今尚未下订单的客户
    mysql> select customers.cust_id,cust_name,order_num from customers left join orders on customers.cust_id=orders.cust_id;
    +---------+----------------+-----------+
    | CUST_ID | CUST_NAME      | ORDER_NUM |
    +---------+----------------+-----------+
    |    1003 | ACME           |      NULL |
    |   10001 | Coyote Inc.    |     20005 |
    |   10001 | Coyote Inc.    |     20009 |
    |   10001 | Coyote Inc.    |     20010 |
    |   10005 | E Fudd         |     20008 |
    |    1004 | Furball Inc.   |      NULL |
    |    1005 | Jet Set        |      NULL |
    |    1006 | Jouets Et Ours |      NULL |
    |    1002 | LT Supplies    |      NULL |
    |   10002 | Mouse House    |     20011 |
    |   10003 | Wascals        |     20006 |
    |   10004 | Yosemite Place |     20007 |
    +---------+----------------+-----------+
    12 rows in set (0.00 sec)
    
    #2）查询没有被购买过的产品名称
    mysql> select p.prod_name from products p left join orderitems o on p.prod_id=o.prod_id where o.order_num is null;
    +---------------+
    | prod_name     |
    +---------------+
    | Detonator     |
    | Fuses         |
    | JetPack 1000  |
    | Safe          |
    | TNT (1 stick) |
    +---------------+
    5 rows in set (0.00 sec)
    
    #3）查询在2005年9月份没有被购买过的产品信息
    mysql> select distinct p.prod_id,prod_name from products p left join orderitems o on p.prod_id=o.prod_id left join (select * from orders where date(order_date) not between "2005-09-01" and "2005-09-30") a on o.order_num=a.order_num where a.order_num is null;
    +---------+----------------+
    | prod_id | prod_name      |
    +---------+----------------+
    | ANV01   | .5 ton anvil   |
    | ANV02   | 1 ton anvil    |
    | DTNTR   | Detonator      |
    | FB      | Bird seed      |
    | FU1     | Fuses          |
    | JP1000  | JetPack 1000   |
    | JP2000  | JetPack 2000   |
    | SAFE    | Safe           |
    | TNT1    | TNT (1 stick)  |
    | TNT2    | TNT (5 sticks) |
    +---------+----------------+
    10 rows in set (0.00 sec)
    ```
    
    

- 右外连接

  - 语法：select * from 表1 right join 表2 on 条件；
  - 计算规则：与左连接相反，以右边表为基准，用右边表的每一行去匹配左边表的每一行，如果满足连接的条件，就组成一行返回，如果连接的字段只在右边表存在，在左边表不存在，那么在结果中就只显示右边表的字段，左边表中不存在的字段用空值NULL来表示。
  - 举例：

  ```sql
  #统计每个客户下了哪些订单，包括那些至今尚未下订单的客户。（用右连接实现）
  mysql> select customers.cust_id,cust_name,order_num from orders right join customers on customers.cust_id=orders.cust_id;
  +---------+----------------+-----------+
  | CUST_ID | CUST_NAME      | ORDER_NUM |
  +---------+----------------+-----------+
  |    1003 | ACME           |      NULL |
  |   10001 | Coyote Inc.    |     20005 |
  |   10001 | Coyote Inc.    |     20009 |
  |   10001 | Coyote Inc.    |     20010 |
  |   10005 | E Fudd         |     20008 |
  |    1004 | Furball Inc.   |      NULL |
  |    1005 | Jet Set        |      NULL |
  |    1006 | Jouets Et Ours |      NULL |
  |    1002 | LT Supplies    |      NULL |
  |   10002 | Mouse House    |     20011 |
  |   10003 | Wascals        |     20006 |
  |   10004 | Yosemite Place |     20007 |
  +---------+----------------+-----------+
  12 rows in set (0.00 sec)
  ```

- 课堂练习：
  - 1、查询老师的姓名及教授的课程名称，包括没有上课的老师？
  - 2、查询没有上课的老师姓名？
  - 3、查询没有被购买过的产品名称？
  - 4、查询每个学生的姓名、学习的课程名称、分数？

### 13.3 inner join、left join、right join三者的区别

借助集合的概念来理解三种连接的区别：

<img src="https://gitee.com/charlesshenchuan/markdown-image-bed/raw/master/Typora/img/image-20210807152243948.png" alt="image-20210807152243948" style="zoom:80%;" />

三者的计算规则是不一样的，其中：

- inner join的计算规则是，用左边表的每一行去匹配右边表的每一行，如果满足连接的条件，就组成一行返回，返回的行里面包括两张表的所有字段，如果不满足连接的条件，就不返回。

- left join的计算规则是：以左边表为基准，用左边表的每一行去匹配右边表的每一行，如果满足连接的条件，就组成一行返回，如果连接的字段值只在左边表存在，在右边表不存在，那么在结果中就只显示左边表的字段值，右边表中的字段用空值来表示。

- right join的计算规则是：以右边表为基准，用右边表的每一行去匹配左边表的每一行，如果满足连接的条件，就组成一行返回，如果连接的字段值只在右边表存在，在左边表不存在，那么在结果中就只显示右边表的字段值，左边表中的字段用空值null来表示。



## 14. 组合查询

- 可用union操作符来组合数条SQL查询，利用union可以将多条select语句组合起来，将它们的结果组合成单个结果集。
- 语法：
  - select * from 表 where 条件 union select * from 表 where 条件；
  - select * from 表 where 条件 union all select * from 表 where 条件；
  - union和union all的区别：union会对结果自动去重，union all不会去重。
- 注意：两个select语句应该有相同数量的列，数据类型要相同或者可以兼容。
- 举例：

```sql
#查询价格小于等于5的产品以及供应商1001和1002生产的所有产品（不考虑价格）。
mysql> select vend_id,prod_id,prod_price from products where prod_price<=5
    -> union
    -> select vend_id, prod_id,prod_price from products where vend_id in (1001,1002);
+---------+---------+------------+
| VEND_ID | PROD_ID | PROD_PRICE |
+---------+---------+------------+
|    1003 | FC      |       2.50 |
|    1002 | FU1     |       3.42 |
|    1003 | SLING   |       4.49 |
|    1003 | TNT1    |       2.50 |
|    1001 | ANV01   |       5.99 |
|    1001 | ANV02   |       9.99 |
|    1001 | ANV03   |      14.99 |
|    1002 | OL1     |       8.99 |
+---------+---------+------------+
8 rows in set (0.01 sec)

#查询价格小于等于5的产品以及供应商1001和1002生产的所有物品（不考虑价格）。
mysql> select vend_id,prod_id,prod_price from products where prod_price<=5
    -> union all
    -> select vend_id, prod_id,prod_price from products where vend_id in (1001,1002);
+---------+---------+------------+
| VEND_ID | PROD_ID | PROD_PRICE |
+---------+---------+------------+
|    1003 | FC      |       2.50 |
|    1002 | FU1     |       3.42 |
|    1003 | SLING   |       4.49 |
|    1003 | TNT1    |       2.50 |
|    1001 | ANV01   |       5.99 |
|    1001 | ANV02   |       9.99 |
|    1001 | ANV03   |      14.99 |
|    1002 | FU1     |       3.42 |
|    1002 | OL1     |       8.99 |
+---------+---------+------------+
9 rows in set (0.01 sec)
```



## 15. 索引Index
索引是一种数据结构，作用是可以提高查询的效率。在数据库表中，可以对某个字段创建索引，有索引的字段在查询效率上会明显比没有索引的要快。索引是针对每个字段创建的。主键和外键会自动创建索引。

举例：

```sql
#查询表有哪些索引
show index from customers;
#创建索引
create index state_index on customers(cust_state);
#删除索引
drop index state_index on customers;
```

但是在实际使用中，我们不会对每个字段都创建索引，一般我们会对经常被查询的字段或者是经常被用来作为连表条件的字段创建索引。



## 16. 视图View

视图是一张虚拟的表，视图的数据来自于SQL语句从真正的表中查询得到，视图支持查询，但不支持增删改操作。

举例：

```sql
#创建一个视图
create view cust_name_prod_id as 
select customers.`cust_name`,orderitems.`prod_id` from customers inner join orders on customers.`cust_id`=
orders.`cust_id` inner join orderitems on orders.`order_num`=orderitems.`order_num`;
#列出订购物品编号TNT2的所有客户姓名
select * from cust_name_prod_id where prod_id="TNT2";
```



## 17. SQL语句的分类

- DQL（数据查询语言）：select
- DML（数据库操纵语言）：insert into/delete from/update等
- DDL（数据库描述语言）：create/alter/drop等
- DCL（数据库控制语言）：grant/commit/rollback等

SQL语言，所有关系型数据库的操作都是基于SQL语句来实现。



## 18. 数据库的导入和导出

- 导出：把数据库的结构和数据转储为SQL脚本，也叫备份数据库

- 导入：执行SQL脚本创建数据库、表、插入数据，也叫恢复数据库

- 方法一：在Linux主机上通过命令导出和导入

  - 导出命令：mysqldump -u用户名 -p密码  数据库名称>SQL脚本文件的路径
    - 举例：mysqldump -uroot -p123456 crashcourse>/usr/local/src/crashcourse_33.sql

  - 导入命令：先用mysql命令登录数据库，再用source命令执行SQL脚本，如果SQL脚本中没有创建数据库的语句，就需要先手动创建。
    - 举例：![img](https://api2.mubu.com/v3/document_image/452c3aa4-9591-415f-95b5-4bef373bbed4-3400539.jpg)

- 方法二：通过数据库客户端导出和导入，以SQLyog为例

  - 导出：![img](https://api2.mubu.com/v3/document_image/731bc683-f046-45a7-9264-8e5bc0a113a4-3400539.jpg)

  - 导入：![img](https://api2.mubu.com/v3/document_image/b181e2e9-b93f-4f1e-a5cf-c3ad79307de8-3400539.jpg)



## 19. 作业

### 第一天

写出如下的SQL语句

1. 创建一个数据库testdb，并在testdb数据库中完成下列操作
2. 创建一个课程表Course，包括课程id、课程名称、上课老师id这三个字段
3. 创建一个老师表Teacher，包括老师id、老师姓名这两个字段
4. 修改课程表，增加一个课程描述的字段
5. 删除课程表的课程描述字段
6. 删除testdb数据库

### 第二天

基于上课的crashcourse数据库写出如下SQL语句：

1. 选择出customers表中cust_email字段用户名是3个字符的客户id；
2. 在products表找出1003供应商的最小产品价格；
3. 在products表中找出备注字段包含‘red’的产品价格；
4. 查找出products表中供应商id、产品名称、产品价格，以供应商id升序排列，当供应商id相同时以价格降序排序；
5. 在客户表中选出cust_state是‘OH，HO，AZ，AC，LI，ZB，TC，WA’的客户id；
6. 在客户表里选出cust_id是10005，或者cust_city是‘Detroit’的客户地址；
7. 在客户表中找出客户名字是‘E Fudd’或者国家是‘USA’，并且email地址不为空的客户id；
8. 在产品表中找出供应商id是1003，且产品价格在5（含）和10（含）之间的供应商id，产品名称、产品价格；

参考答案：

1. SELECT cust_id FROM customers WHERE cust_email LIKE "___@%";
2. SELECT prod_price FROM products WHERE vend_id=1003 ORDER BY prod_price ASC LIMIT 1 ;
3. SELECT prod_price FROM products WHERE prod_desc  LIKE "%red%"
4. SELECT vend_id,prod_name,prod_price FROM products  ORDER BY vend_id ASC,prod_price DESC;
5. SELECT cust_id FROM customers WHERE cust_state IN("OH","HO","AZ","AC","LI","ZB","TC","WA");
6. SELECT cust_address FROM customers WHERE cust_id=10005 OR cust_city="Detroit";
7. SELECT cust_id FROM customers WHERE (cust_name="E Fudd" OR cust_country="USA" ) AND cust_email IS NOT NULL;
8. SELECT vend_id,prod_name,prod_price FROM products WHERE vend_id=1003 AND prod_price BETWEEN 5 AND 10;

### 第三天

1. 查询9月份订单的80天后收款的日期
2. 查询2005年10月之前的订单信息
3. 按月统计2005年的订单数量
4. 统计2005年单月最大的订单数量
5. 选出高于1003供应商的所有产品的价格的产品编号、产品名称、产品价格
6. 列出购买产品id为OL1的订单购买的其他产品编号和订单号
7. 列出供应商的平均价格大于20的供应商编号
8. 查询出购买2种以上价格大于5的物品的订单编号

### 第四天

1. 查询出今天没有人订购的菜名（分别使用左连接、右连接表示）

2. 查询出订餐用户的姓名、联系方式、菜品名称

3. 查询出目前为止没有订餐的会员信息（分别使用左连接、右连接表示）、

4. 查询出目前没有被会员订购的菜品信息（分别使用左连接、右连接表示）

5. 查询出目前已经订餐的非会员的姓名、联系方式

6. 查询出会员和已下订单用户的姓名、联系方式

   

参考答案：

1. SELECT dish_name FROM dishes LEFT JOIN (SELECT DISTINCT dish_id FROM orders WHERE DATE(order_date) = "2021-06-15") AS o ON dishes.dish_id = o.dish_id WHERE o.dish_id IS NULL;
2. SELECT  user_name,  telephone,  dish_name FROM  orders u  LEFT JOIN order_users o  ON u.user_id = o.user_id  LEFT JOIN dishes d ON u.dish_id = d.dish_id ;
3. SELECT vips.* FROM vips LEFT JOIN order_users o ON vips.`vip_num` = o.`vip_num` WHERE o.`vip_num` IS NULL ;
4. SELECT * FROM dishes LEFT JOIN (SELECT dish_id FROM orders WHERE user_id IN (SELECT user_id FROM order_users WHERE vip_num IS NOT NULL)) AS A ON dishes.dish_id = A.dish_id WHERE A.dish_id IS NULL ;
5. SELECT DISTINCT  user_name,  telephone FROM  orders o  LEFT JOIN order_users ou  ON o.user_id = ou.user_id WHERE vip_num IS NULL ;
6. SELECT  vip_name,  vip_phone FROM  vips UNION SELECT  user_name,  telephone FROM  order_users ;

